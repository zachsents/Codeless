import { createHash } from "crypto"
import { nanoid } from "nanoid"


/**
 * @typedef {object} ServerOAuth2ManagerOptions
 * @property {string} clientId
 * @property {string} clientSecret
 * @property {string} callbackUrl
 * @property {string[]} scopes
 * @property {function} getState
 * @property {function} setState
 * @property {function} getAuthInfo
 * @property {function} setAuthInfo
 * @property {(userId: string) => *} createAccountKey
 * 
 * @property {string} authorizationEndpoint
 * @property {string} tokenEndpoint
 * @property {string} whoamiEndpoint
 * @property {number} stateLength
 * @property {boolean} useCodeChallenge
 * @property {number} codeVerifierLength
 * @property {boolean} closeWindowOnSuccess
 * 
 * @property {string} debugPrefix
 */


/**
 * @typedef {Omit<ServerOAuth2ManagerOptions, 'authorizationEndpoint' | 'tokenEndpoint' | 'whoamiEndpoint' | 'stateLength' | 'useCodeChallenge' | 'codeVerifierLength' | 'closeWindowOnSuccess' | 'debugPrefix'>} ServerOAuth2ManagerConfigurableOptions
 */


export class ServerOAuth2Manager {

    static isWithinCachedTimePeriod(timestampMs, cacheTimeMins = 5) {
        return timestampMs > Date.now() - cacheTimeMins * 60 * 1000
    }

    /**
     * Creates an instance of ServerOAuth2Manager.
     * @param {ServerOAuth2ManagerOptions} options
     * @memberof ServerOAuth2Manager
     */
    constructor(options) {
        this.options = options
    }

    /**
     * Generates an authorization URL.
     *
     * @param {*} payload
     * @return {string} 
     * @memberof ServerOAuth2Manager
     */
    async generateAuthUrl(payload = {}) {

        // Generate state
        const state = nanoid(this.options.stateLength)

        // Optional - Generate code challenge
        if (this.options.useCodeChallenge) {
            var codeVerifier = nanoid(this.options.codeVerifierLength)
            var codeChallenge = this.hashCodeVerifier(codeVerifier)
        }

        // Store state & code challenge
        await this.options.setState({
            state,
            payload,
            ...(this.options.useCodeChallenge && { codeVerifier }),
        })

        // Set up search params
        const params = new URLSearchParams({
            client_id: this.options.clientId,
            redirect_uri: this.options.callbackUrl,
            response_type: "code",  // footnote 1
            scope: this.options.scopes.join(" "),   // footnote 1
            state,
        })

        // Optional - Append code challenge
        if (this.options.useCodeChallenge) {
            params.append("code_challenge", codeChallenge)
            params.append("code_challenge_method", "S256")  // footnote 1
        }

        // Construct URL
        return `${this.options.authorizationEndpoint}?${params.toString()}`
    }

    /**
     * Responds to a request with an authorization URL generated by
     * ServerOAuth2Manager.generateAuthUrl.
     * @memberof ServerOAuth2Manager
     */
    async respondWithAuthUrl(res, payload) {
        res.redirect(await this.generateAuthUrl(payload))
    }

    /**
     * Handles the authorization callback from the OAuth2 provider.
     * @memberof ServerOAuth2Manager
     */
    async handleAuthorizationCallback(req, res) {

        // Pull out query params
        const {
            code: grantCode,
            state,
            code_challenge: codeChallenge,
            error,
            error_description: errorDesc,
        } = req.query

        // Check for errors
        if (error)
            this.throw(res, { error, description: errorDesc })

        // Get state
        const storedDocument = await this.options.getState(state)

        // Check if state exists
        if (!storedDocument)
            this.throw(res, { error: "invalid_state", description: "State doesn't exist" })

        // Optional - Verify code challenge
        if (
            this.options.useCodeChallenge &&
            codeChallenge != this.hashCodeVerifier(storedDocument.codeVerifier)
        )
            this.throw(res, {
                error: "invalid_code_challenge",
                description: "Code challenge doesn't match"
            })

        // Make request to create token
        const {
            access_token: accessToken,
            refresh_token: refreshToken,
            expires_in: expiresIn,
            refresh_expires_in: refreshExpiresIn,
            token_type: tokenType,
        } = await this.fetchToken({
            code: grantCode,
            redirect_uri: this.options.callbackUrl,
            grant_type: "authorization_code",   // footnote 1

            // Optional - Add code verifier
            ...(this.options.useCodeChallenge && { code_verifier: storedDocument.codeVerifier })
        }, res)

        // Get user ID and granted scopes
        const { id: userId, scopes: grantedScopes } = await this.whoAmI(accessToken)

        // Store auth info
        await this.options.setAuthInfo.call(this, this.options.createAccountKey(userId), {
            userId,
            accessToken,
            refreshToken,
            expiresAt: Date.now() + expiresIn * 1000,
            refreshExpiresAt: Date.now() + refreshExpiresIn * 1000,
            tokenType,
            scopes: grantedScopes,
            payload: storedDocument.payload,
        })

        // Respond
        this.responseToSuccessfulAuthorization(res)
    }

    responseToSuccessfulAuthorization(res) {
        res.send(
            // Optional - Respond with JS to close the popup window
            this.options.closeWindowOnSuccess ?
                "<script>window.close()</script>" :
                "Success! You can close this window now."
        )
    }

    async getAccessToken(accountKey, additionalState) {

        // Get auth info
        const authInfo = await this.options.getAuthInfo.call(this, accountKey, additionalState)

        // Check if access token exists
        if (!authInfo?.accessToken)
            this.throw(undefined, { error: "no_access_token", description: "No access token" })

        // We'll only check with the whoami endpoint if the access token hasn't expired        
        if (authInfo.expiresAt > Date.now()) {

            // See if access token has been checked in the last 5 minutes
            if (authInfo.checkedAt && ServerOAuth2Manager.isWithinCachedTimePeriod(authInfo.checkedAt))
                return console.debug(this.options.debugPrefix, "Authorized! (cached check in last 5 mins)"), authInfo.accessToken

            // Check if access token is good via whoami endpoint
            const isAccessTokenGood = await this.whoAmI(authInfo.accessToken)
                .then(() => true)
                .catch(() => false)

            // If it's good, return it
            if (isAccessTokenGood) {
                // We'll also store the time checked
                await this.options.setAuthInfo.call(this, accountKey, {
                    ...authInfo,
                    checkedAt: Date.now(),
                }, additionalState)

                return console.debug(this.options.debugPrefix, "Authorized! (via whoami)"), authInfo.accessToken
            }
        }

        // If it's not good...

        // Check if refresh token exists
        if (!authInfo?.refreshToken)
            this.throw(undefined, { error: "no_refresh_token", description: "No refresh token" })

        // Refresh token
        const {
            access_token: newAccessToken,
            refresh_token: newRefreshToken,
            expires_in: expiresIn,
            refresh_expires_in: refreshExpiresIn,
        } = await this.fetchToken({
            refresh_token: authInfo.refreshToken,
            grant_type: "refresh_token",    // footnote 1
        })

        // Store new auth info
        await this.options.setAuthInfo.call(this, accountKey, {
            ...authInfo,
            accessToken: newAccessToken,
            refreshToken: newRefreshToken,
            expiresAt: Date.now() + expiresIn * 1000,
            refreshExpiresAt: Date.now() + refreshExpiresIn * 1000,
            checkedAt: 0,
        }, additionalState)

        newAccessToken && console.debug(this.options.debugPrefix, "Authorized! (via refesh)")
        return newAccessToken

        // Might need ot add something to clear the auth info if the refresh token expires.
        // We'll know because the call to refresh it will fail.
    }

    /**
     * Fetches the token endpoint. This is used for initially creating
     * tokens with a grant code and for refreshing tokens, which you pass
     * different bodies for.
     *
     * @param {object} body
     * @memberof ServerOAuth2Manager
     */
    async fetchToken(body, res) {
        // Make request to token endpoint
        const response = await fetch(this.options.tokenEndpoint, {
            method: "POST",
            headers: {
                ...this.basicAuthorizationHeader(),
                "Content-Type": "application/x-www-form-urlencoded",
            },
            body: new URLSearchParams(body).toString()
        }).then(res => res.json())

        // Check for errors
        if (response.error)
            this.throw(res, { error: response.error, description: response.error_description })

        return response
    }

    /**
     * Fetches the who am i endpoint
     *
     * @param {string} accessToken
     * @memberof ServerOAuth2Manager
     */
    async whoAmI(accessToken) {

        const response = await fetch(this.options.whoamiEndpoint, {
            headers: this.bearerAuthorizationHeader(accessToken)
        }).then(res => res.json())

        if (response.error)
            this.throw(undefined, { error: "who_am_i_failed", description: response.error.message })

        return response
    }

    /**
     * Checks if the account represented by the passed account key is
     * authorized.
     *
     * @param {*} accountKey
     * @return {Promise<boolean>} 
     * @memberof ServerOAuth2Manager
     */
    async isAuthorized(accountKey, additionalState) {
        try {
            await this.getAccessToken(accountKey, additionalState)
            return true
        }
        catch (err) {
            console.debug(this.options.debugPrefix, "Not authorized")
            console.debug(err)
            return false
        }
    }

    getAPI() {
        throw new Error("Parent class ServerOAuth2Manager does not implement getAPI(). Use a subclass with an API instead.")
    }

    /**
     * Uses a stategy for this manager.
     *
     * @param {import("./Strategy.js").Strategy} strategy
     * @memberof ServerOAuth2Manager
     */
    use(strategy) {
        // Merge options
        this.options = {
            ...this.options,
            ...strategy.useOptions(),
        }

        // Merge functions
        Object.entries(
            strategy.useFunctionOverrides(this)
        ).forEach(([fnName, fn]) => {
            this[fnName] = fn
        })
    }

    basicAuthorizationHeader() {
        return {
            "Authorization": "Basic " + Buffer.from(`${this.options.clientId}:${this.options.clientSecret}`).toString("base64"),
        }
    }

    bearerAuthorizationHeader(token) {
        return {
            "Authorization": "Bearer " + token,
        }
    }

    hashCodeVerifier(codeVerifier) {
        const hash = createHash("sha256")
        hash.update(codeVerifier)
        return hash.digest("base64url")
    }

    throw(res, { error, description, status = 500 }) {
        res?.status(status).send({ error, description })
        throw new Error(`OAuth2 Error: ${error} - ${description}`)
    }
}



/**
 * 1. These values are from the Airtable docs. They're likely different for other services,
 *   but we'll make them configurable as we need to later.
 */